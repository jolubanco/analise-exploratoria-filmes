# -*- coding: utf-8 -*-
"""Introdução a Data Science.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g8zXBhlAP5c_hIGi9-F6Xl51UGcsL3Y7
"""

#!pip install seaborn==0.11.1#foi preciso instalar a versão 0.9.0 do seaborn pois a função catplot não estava disponível em versões inferiores
#import seaborn as sns
#print(sns.__version__)

"""#Analisando as notas em geral"""

import pandas as pd #biblioteca para trabalhar com arquivos csv
notas =pd.read_csv('ratings.csv') #lendo o arquivo csv
notas.head() #mostra apenas os 5 primeiro itens do arquivo csv

notas.shape #formato dos meus dados, em linhas e colunas

notas.columns = ['usuarioId', 'filmeId', 'nota', 'momento']  #renomear os títulos das tabelas

notas.head()

type(notas) #Data Frame

notas['nota'] # Retorna uma coluna do data frame, chamado de 'Series'
#podemos utilizar notas.nota

notas['nota'].unique() #Retorna os valores únicos da minha série

notas['nota'].value_counts() #Retorna o número de vezes que cada nota foi dada

notas['nota'].mean() #média das notas atribuidas

notas.nota #outra forma de buscar a coluna, mais utilizada 'variavel.nome_coluna'

notas.nota.plot() #plota os dados da coluna(série) notas
# Porem o plot, sem parâmetros, está levando em consideração o índice, do dataframe

notas.nota.plot(kind ='hist') #atribuímos o tipo 'Histograma' ao plot, o que retorna um grafico de frequência que os dados aparecem

print('Média:', notas.nota.mean())
print('Mediana:', notas.nota.median()) #mediana dos meus dados, 50% dos dados são menores que a mediana e 50% são maiores

notas.nota.describe() #oferece varias medidas de descrição dos meus dados, serve também para o dataframe

import seaborn as sns #biblioteca de visualizão de dados
sns.boxplot(notas.nota)

#exploratory data analysis

"""#Olhando os filmes"""

filmes = pd.read_csv('movies.csv')
filmes.columns = ['filmeID', 'titulo', 'generos']
filmes.head()

notas.head()

notas.query('filmeId == 1') #'query' faz uma 'pergunta' para o dataframe e exibe os valores que retornam True

notas.query('filmeId == 1').nota #quando estou interessado apenas na coluna nota

"""#Analisando algumas notas específicas por filme

"""

notas.query('filmeId == 1').nota.mean() #media das notas do filmeId == 1

notas.query('filmeId == 2').nota.mean()

notas.groupby('filmeId') #agrupa o dataframe notas pela coluna filmeId

notas.groupby('filmeId').mean() #agrupa o dataframe notas pela coluna filmeId, e tira a media

medias_por_filme = notas.groupby('filmeId').mean().nota #extrai apenas a coluna nota, pois as outras não trazem informações relevantes

medias_por_filme.head()

medias_por_filme.plot(kind = 'hist')

sns.boxplot(medias_por_filme) #é apresentado na horizontal por padrão

sns.boxplot(y=medias_por_filme) # Apresenta o boxplot na vertical, como é mais utilizado

medias_por_filme.describe()

sns.distplot(medias_por_filme) #histograma pelo seaborn

sns.distplot(medias_por_filme, bins=10) #parametro bins indicada quantos valores na particao
#tomar cuidado com o valor do 'bins', para nao passar uma ideia errada
# sem o parametro ele tenta escolher o melhor valor para o 'bins'

import matplotlib.pyplot as plt #biblioteca de baixo nivel que o pandas e o seaborn usam

plt.hist(medias_por_filme) #histograma
plt.title('Histograma das médias dos filmes') #adiciona um título ao histograma

# utilizando o pyplot para redimensionar a imagem
plt.figure(figsize=(5,8)) #redimensiona a proporção da imagem gerada pelo seaborn
sns.boxplot(y=medias_por_filme)

tmdb = pd.read_csv('tmdb_5000_movies.csv') # utilizando outro banco de dados de filmes
tmdb.head()

tmdb.shape

tmdb.original_language.unique() #variável categorica nominal, sem ordem definida

tmdb.vote_average.unique()

tmdb.original_language

tmdb.original_language.value_counts() #conta a frequencia que cada lingua aparece (uma série)
# neste caso temos apenas uma coluna, os idiomas são apenas os índices

#para criar um dataframe com os indices e os valores
tmdb.original_language.value_counts().to_frame()

contagem_de_lingua = tmdb.original_language.value_counts().to_frame().reset_index() # faz com que os idiomas nao sejam mais um indice e sim uma coluna
#cria um novo indice numérico(contador)

contagem_de_lingua.columns = ['original_language','total']

contagem_de_lingua.head()

# plotar categorias de dados, usando seaborn
sns.barplot(x='original_language', y='total', data = contagem_de_lingua) #data são os dados que serão plotados (gráfico de barras)
# podemos escolher x e y desta forma porque criamos um dataframe

sns.catplot(x='original_language', kind='count', data=tmdb) #evita ter que criar o dataframe
# faz um plote direto das categorias, mais rigido que o barplot

"""#Data Visualization"""

plt.pie(contagem_de_lingua['total'], labels = contagem_de_lingua['original_language'])
#gera um grafico de 'pizza' ou 'pie' com os dados 'total' e com os rótulos 'original_language'
#o grafico de 'pie' não costuma ser recomendado para quase nenhuma situação

total_por_lingua = tmdb.original_language.value_counts()
total_por_lingua

total_de_ingles = total_por_lingua.loc['en'] #localiza o valor correspondente a categoria 'en'.
total_geral = total_por_lingua.sum() #soma dos os valores
total_do_resto = total_geral - total_de_ingles
print(total_de_ingles,total_do_resto)

dados = {
    'lingua':['ingles','outros'],
    'total':[total_de_ingles, total_do_resto]
}
#criando um dicionário do pandas para armazenar os dados
dados = pd.DataFrame(dados) #cria um dataframe pelo pandas com respeito ao dicionário 'dados'
dados

sns.barplot(x='lingua', y='total', data = dados)
# uma visualização bem melhor que as demais

plt.pie(dados['total'], labels=dados['lingua'])
#graficos de pizza não são bons para analisar proporcionalmente a diferença

total_por_lingua_de_outros_filmes = tmdb.query("original_language != 'en'").original_language.value_counts()

total_por_lingua_de_outros_filmes.head()

filmes_sem_lingua_original_em_ingles = tmdb.query("original_language != 'en'")
plt.figure(figsize=(5,10)) #desta forma não gera alteração na figura, pois o catplot é de alto nivel e não permite altereações externas
#para modificar a imagem na função catplot é preciso usar os parametros da função
sns.catplot(x='original_language', kind='count',data= filmes_sem_lingua_original_em_ingles)

sns.catplot(x='original_language', kind='count',
            data= filmes_sem_lingua_original_em_ingles, aspect=2)
#com a atributo 'aspect=2' ela vai plotar a imagem com a proporção 2:1, se fosse 'aspect=1' seria um quadrado

#queremos apresentar as barras do grafico em uma ordem de maior frequeência de aparição
#já conseguimos order os dados com essa ordem
total_por_lingua_de_outros_filmes.head()

#agora basta passar o parametro order, com valor total_por_lingua_de_outros_filmes ordenando peo índice
sns.catplot(x='original_language', kind='count',
            data= filmes_sem_lingua_original_em_ingles,
            aspect=2, 
            order = total_por_lingua_de_outros_filmes.index)

#queremos apresentar o grafico em um tom degradê, com as cores escurecendo com as menores frequencias, para ser mais visual
#para isso usamos o parametro 'palette' e buscamos nas documentação as variações
sns.catplot(x='original_language', kind='count',
            data= filmes_sem_lingua_original_em_ingles,
            aspect=2, 
            palette ='GnBu_d',
            order = total_por_lingua_de_outros_filmes.index,)

#comparação com o que tinhamos e com o que obtemos agora
sns.catplot(x='original_language', kind='count',data= filmes_sem_lingua_original_em_ingles)

"""#Dados e Estatística"""

filmes.head(2)

notas.head()

notas_do_toy_story = notas.query('filmeId == 1')
notas_do_jumanji = notas.query('filmeId == 2')
print(len(notas_do_toy_story), len(notas_do_jumanji))

print('Nota média da Toy Story:  %.2f' % notas_do_toy_story.nota.mean()) 
print('Nota média da Jumanji:  %.2f' % notas_do_jumanji.nota.mean()) 
#%.2f informa que queremos duas casas decimais no ponto flutuante e % o valor a ser concatenado

print('Mediana das notas de Toy Story: %.2f' % notas_do_toy_story.nota.median()) 
print('Mediana das notas de Jumanji: %.2f' % notas_do_jumanji.nota.median())

import numpy as np
filme_1 = np.append(np.array([2.5]*10),np.array([3.5]*10)) #concatena dois arrays
filme_2 = np.append(np.array([5]*10),np.array([1]*10))

print(filme_1.mean(),filme_2.mean())
print(np.std(filme_1),np.std(filme_2)) # Desvio padrão no numpy
#print(filme_1.median(),filme_2.median())) no NumPy o comando mediana não é da mesma forma que no pandas
print(np.median(filme_1),np.median(filme_2))

plt.hist(filme_1)
plt.hist(filme_2)

sns.boxplot(filme_1)

plt.boxplot([filme_1,filme_2])

sns.boxplot(notas_do_toy_story.nota)
sns.boxplot(notas_do_jumanji.nota) #assim fica ruim porque eles se sobrepoem

plt.boxplot([notas_do_toy_story.nota,notas_do_jumanji.nota])

sns.boxplot(x='filmeId', y = 'nota', data = notas.query('filmeId in [1,2,3,4,5]'))

# o desvio padrão nos diz quanto os dados estão 'distantes' de uma medida central

print(notas_do_jumanji.nota.std(),notas_do_toy_story.nota.std()) #desvio padrão no pandas

